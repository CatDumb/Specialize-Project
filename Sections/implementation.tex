%
% This is the TeX file for the implementation section
%
\section{IMPLEMENTATION}

\subsection{Bus Services Integration}

\subsubsection{Getting a single route's information}

The integrity of the data on the Buyt TPHCM website is guaranteed due to its commissioning and maintenance by the Ho Chi Minh City Department of Transport. 

Several JavaScript source files power this site:
\begin{itemize}
    \item \textbf{L.Config.js:} This is a configuration file to set up the map rendering for Buyt TPHCM. The tiles are loaded from http://map.stis.vn/bright/{z}/{x}/{y}.png.
    \item \textbf{L.RouteMap.js:} This source file is responsible for showing the stops and bus routes. We were able to get the coordinate sets that we wanted by placing breakpoints on this file.
\end{itemize}

\begin{figure}[H]
    \includegraphics[width=\textwidth]{assets/images/Research/Bus/lat_long_web.png}
    \caption{Capturing and observing the route data using the DevTool}
    \label{fig:lat_long_web}
\end{figure}

By inserting breakpoints in L.RouteMap.js, we can easily obtain the coordinates of the route, as demonstrated on the right-hand side. It is worth mentioning that while the coordinates are given in both distinct arrays and a single array with integrated data, it is more advantageous to utilize the latitudes and longitudes in separate arrays. The reason for this is that the present system implementation utilizes MongoDB, which does not allow tuples due to its implementation of BSON.

When it is desirable to work with a single array of coordinates, the stored data can be retrieved and combined together. Below is an example where we zip the arrays and plot them using Matplotlib (please note that since there are over 600 elements in each array, 668 to be exact, a figurative number was put in the code excerpt)

\begin{lstlisting}[language=python]
    lat = [10.001, 10.002] # the latitudes
    lng = [106.001, 106.002] # the longitudes
    coordinates = [(lat[i], lng[i]) for i in range(min(len(lat), len(lng)))]
    # Extract latitudes and longitudes from the coordinates
    latitudes, longitudes = zip(*coordinates)
    
    # Create a scatter plot to mark the coordinates
    plt.scatter(longitudes, latitudes, color='red', marker='o', label='Coordinates')
    
    # Create a line plot to draw the polyline
    plt.plot(longitudes, latitudes, color='blue', label='Polyline')
    
    # Set labels for the x and y axes
    plt.xlabel('Longitude')
    plt.ylabel('Latitude')
    
    # Add a legend
    plt.legend()
    
    # Display the plot
    plt.show()
\end{lstlisting}

The result is as follow:
\begin{figure}[H]
    \centering
    \subfloat[The Matplotlib representation of the bus route 8.]{
        \includegraphics[width=0.4\linewidth]{assets/images/Research/Bus/plot_route.png}
        \label{fig:plot-route}
    }
    \hspace{0.5cm} % Add a horizontal space of 0.5 cm
    \subfloat[The actual route 8 from Buyt TPHCM.]{
        \includegraphics[width=0.4\linewidth]{assets/images/Research/Bus/actual_route.png}
        \label{fig:actual_route}
    }
\end{figure}

Similarly, information about the bus stops can be obtained by placing breakpoints in L.RouteMap.js. Each route comes with a list of stops and their corresponding data. This will be useful in designing our data schema later on when we integrate the gathered information into our database.

\begin{figure}[H]
    \includegraphics[width=\textwidth]{assets/images/Research/Bus/stop_web.png}
    \caption{Capturing and observing the bus stops data using the DevTool}
    \label{fig:stop_data}
\end{figure}

\subsubsection{Automation of the mining process}

Since there are about 130 routes currently displayed on the website, it is impossible to place breakpoints and collect data by hand. This necessitates the use of automatic scripts to gather information.

After careful examination, we found several places where we could mine the data. This introduces us to the routevar.js file, which contains the three functions: loadVarsByRou(rouId), loadStopsByVar(prtId, rouId, varId), and loadPathByVar(prtId, rouId, varId)

\subsubsection{Data storage of bus services}

\subsection{iOS App Development}
We are determined to develop an equivalent iOS app for the project in order to provide a more complete experience for the users. The app is developed using Swift 5.9 and Xcode 15. The app is compatible with iOS 16.0 and above.

First and foremost, this app must at least offer the basic functionalities like that of the Android counterpart. This includes authentication, viewing the traffic status report, and being able to communicate with the server. Other requirements are that the app must also be lightweight, performant, and consistent with the ongoing design of the Android app to an extent. During the developement of this prototype, we have also taken into consideration the possibility of future expansion, such as adding more features and improving the user experience, as well as following Apple's best practices when it comes to iOS app development.

\subsubsection{The landing page and permission requests}
Because the UTraffic app must know the user's real-time location in order to gather GPS data and also display nearby traffic status, it is crucial that we ask the users for location permissions upon the first app launch. This is done by presenting a dialog box that asks for the user's permission to access their location. The choice is saved into \lstinline{UserDefaults}, so that this process will not be repeated on subsequent app launches.

\subsubsection{Account registration and login}
We adapt most of the user interface from the Android app to the iOS app in order to provide a consistent experience of the app across platforms. 

\subsubsection{Viewing the traffic status report}


